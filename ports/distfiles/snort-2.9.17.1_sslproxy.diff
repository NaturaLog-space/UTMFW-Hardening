diff -Nur snort-2.9.17.1/configure snort-2.9.17.1_sslproxy/configure
--- snort-2.9.17.1/configure	2021-03-10 16:08:13.000000000 +0300
+++ snort-2.9.17.1_sslproxy/configure	2021-05-30 16:12:32.405394502 +0300
@@ -18590,7 +18590,7 @@
 
 
 
-ac_config_files="$ac_config_files snort.pc Makefile src/Makefile src/sfutil/Makefile src/control/Makefile src/file-process/Makefile src/file-process/libs/Makefile src/side-channel/Makefile src/side-channel/dynamic-plugins/Makefile src/side-channel/dynamic-plugins/snort_side_channel.pc src/side-channel/plugins/Makefile src/detection-plugins/Makefile src/dynamic-examples/Makefile src/dynamic-examples/dynamic-preprocessor/Makefile src/dynamic-examples/dynamic-rule/Makefile src/dynamic-plugins/Makefile src/dynamic-plugins/sf_engine/Makefile src/dynamic-plugins/sf_engine/examples/Makefile src/dynamic-plugins/sf_preproc_example/Makefile src/dynamic-preprocessors/Makefile src/dynamic-preprocessors/libs/Makefile src/dynamic-preprocessors/libs/snort_preproc.pc src/dynamic-preprocessors/ftptelnet/Makefile src/dynamic-preprocessors/smtp/Makefile src/dynamic-preprocessors/ssh/Makefile src/dynamic-preprocessors/sip/Makefile src/dynamic-preprocessors/reputation/Makefile src/dynamic-preprocessors/gtp/Makefile src/dynamic-preprocessors/dcerpc2/Makefile src/dynamic-preprocessors/pop/Makefile src/dynamic-preprocessors/imap/Makefile src/dynamic-preprocessors/sdf/Makefile src/dynamic-preprocessors/dns/Makefile src/dynamic-preprocessors/ssl/Makefile src/dynamic-preprocessors/modbus/Makefile src/dynamic-preprocessors/dnp3/Makefile src/dynamic-preprocessors/s7commplus/Makefile src/dynamic-preprocessors/file/Makefile src/dynamic-preprocessors/appid/Makefile src/dynamic-output/Makefile src/dynamic-output/plugins/Makefile src/dynamic-output/libs/Makefile src/dynamic-output/libs/snort_output.pc src/output-plugins/Makefile src/preprocessors/Makefile src/preprocessors/HttpInspect/Makefile src/preprocessors/HttpInspect/include/Makefile src/preprocessors/HttpInspect/utils/Makefile src/preprocessors/HttpInspect/anomaly_detection/Makefile src/preprocessors/HttpInspect/client/Makefile src/preprocessors/HttpInspect/files/Makefile src/preprocessors/HttpInspect/event_output/Makefile src/preprocessors/HttpInspect/mode_inspection/Makefile src/preprocessors/HttpInspect/normalization/Makefile src/preprocessors/HttpInspect/server/Makefile src/preprocessors/HttpInspect/session_inspection/Makefile src/preprocessors/HttpInspect/user_interface/Makefile src/preprocessors/Session/Makefile src/preprocessors/Stream6/Makefile src/parser/Makefile src/target-based/Makefile doc/Makefile rpm/Makefile preproc_rules/Makefile m4/Makefile etc/Makefile templates/Makefile tools/Makefile tools/control/Makefile tools/u2boat/Makefile tools/u2spewfoo/Makefile tools/u2openappid/Makefile tools/u2streamer/Makefile tools/file_server/Makefile src/win32/Makefile src/reload-adjust/Makefile"
+ac_config_files="$ac_config_files snort.pc Makefile src/Makefile src/sfutil/Makefile src/control/Makefile src/file-process/Makefile src/file-process/libs/Makefile src/side-channel/Makefile src/side-channel/dynamic-plugins/Makefile src/side-channel/dynamic-plugins/snort_side_channel.pc src/side-channel/plugins/Makefile src/detection-plugins/Makefile src/dynamic-examples/Makefile src/dynamic-examples/dynamic-preprocessor/Makefile src/dynamic-examples/dynamic-rule/Makefile src/dynamic-plugins/Makefile src/dynamic-plugins/sf_engine/Makefile src/dynamic-plugins/sf_engine/examples/Makefile src/dynamic-plugins/sf_preproc_example/Makefile src/dynamic-preprocessors/Makefile src/dynamic-preprocessors/libs/Makefile src/dynamic-preprocessors/libs/snort_preproc.pc src/dynamic-preprocessors/ftptelnet/Makefile src/dynamic-preprocessors/smtp/Makefile src/dynamic-preprocessors/ssh/Makefile src/dynamic-preprocessors/sip/Makefile src/dynamic-preprocessors/reputation/Makefile src/dynamic-preprocessors/gtp/Makefile src/dynamic-preprocessors/dcerpc2/Makefile src/dynamic-preprocessors/pop/Makefile src/dynamic-preprocessors/imap/Makefile src/dynamic-preprocessors/sdf/Makefile src/dynamic-preprocessors/dns/Makefile src/dynamic-preprocessors/ssl/Makefile src/dynamic-preprocessors/modbus/Makefile src/dynamic-preprocessors/dnp3/Makefile src/dynamic-preprocessors/s7commplus/Makefile src/dynamic-preprocessors/file/Makefile src/dynamic-preprocessors/appid/Makefile src/dynamic-preprocessors/sslproxy/Makefile src/dynamic-output/Makefile src/dynamic-output/plugins/Makefile src/dynamic-output/libs/Makefile src/dynamic-output/libs/snort_output.pc src/output-plugins/Makefile src/preprocessors/Makefile src/preprocessors/HttpInspect/Makefile src/preprocessors/HttpInspect/include/Makefile src/preprocessors/HttpInspect/utils/Makefile src/preprocessors/HttpInspect/anomaly_detection/Makefile src/preprocessors/HttpInspect/client/Makefile src/preprocessors/HttpInspect/files/Makefile src/preprocessors/HttpInspect/event_output/Makefile src/preprocessors/HttpInspect/mode_inspection/Makefile src/preprocessors/HttpInspect/normalization/Makefile src/preprocessors/HttpInspect/server/Makefile src/preprocessors/HttpInspect/session_inspection/Makefile src/preprocessors/HttpInspect/user_interface/Makefile src/preprocessors/Session/Makefile src/preprocessors/Stream6/Makefile src/parser/Makefile src/target-based/Makefile doc/Makefile rpm/Makefile preproc_rules/Makefile m4/Makefile etc/Makefile templates/Makefile tools/Makefile tools/control/Makefile tools/u2boat/Makefile tools/u2spewfoo/Makefile tools/u2openappid/Makefile tools/u2streamer/Makefile tools/file_server/Makefile src/win32/Makefile src/reload-adjust/Makefile"
 
 
 cat >confcache <<\_ACEOF
@@ -19727,6 +19727,7 @@
     "src/dynamic-preprocessors/s7commplus/Makefile") CONFIG_FILES="$CONFIG_FILES src/dynamic-preprocessors/s7commplus/Makefile" ;;
     "src/dynamic-preprocessors/file/Makefile") CONFIG_FILES="$CONFIG_FILES src/dynamic-preprocessors/file/Makefile" ;;
     "src/dynamic-preprocessors/appid/Makefile") CONFIG_FILES="$CONFIG_FILES src/dynamic-preprocessors/appid/Makefile" ;;
+    "src/dynamic-preprocessors/sslproxy/Makefile") CONFIG_FILES="$CONFIG_FILES src/dynamic-preprocessors/sslproxy/Makefile" ;;
     "src/dynamic-output/Makefile") CONFIG_FILES="$CONFIG_FILES src/dynamic-output/Makefile" ;;
     "src/dynamic-output/plugins/Makefile") CONFIG_FILES="$CONFIG_FILES src/dynamic-output/plugins/Makefile" ;;
     "src/dynamic-output/libs/Makefile") CONFIG_FILES="$CONFIG_FILES src/dynamic-output/libs/Makefile" ;;
diff -Nur snort-2.9.17.1/configure.in snort-2.9.17.1_sslproxy/configure.in
--- snort-2.9.17.1/configure.in	2021-03-10 16:05:37.000000000 +0300
+++ snort-2.9.17.1_sslproxy/configure.in	2021-05-30 16:12:32.405394502 +0300
@@ -1750,6 +1750,7 @@
 src/dynamic-preprocessors/s7commplus/Makefile \
 src/dynamic-preprocessors/file/Makefile \
 src/dynamic-preprocessors/appid/Makefile \
+src/dynamic-preprocessors/sslproxy/Makefile \
 src/dynamic-output/Makefile \
 src/dynamic-output/plugins/Makefile \
 src/dynamic-output/libs/Makefile \
diff -Nur snort-2.9.17.1/src/dynamic-preprocessors/Makefile.am snort-2.9.17.1_sslproxy/src/dynamic-preprocessors/Makefile.am
--- snort-2.9.17.1/src/dynamic-preprocessors/Makefile.am	2021-03-10 16:05:37.000000000 +0300
+++ snort-2.9.17.1_sslproxy/src/dynamic-preprocessors/Makefile.am	2021-05-30 16:12:32.405394502 +0300
@@ -708,7 +708,7 @@
 FILE_INSPECT_DIR = file
 endif
 
-SUBDIRS = . libs ftptelnet pop imap smtp ssh dns ssl dcerpc2 sdf sip reputation gtp modbus dnp3 s7commplus $(FILE_INSPECT_DIR)
+SUBDIRS = . libs ftptelnet pop imap smtp ssh dns ssl dcerpc2 sdf sip reputation gtp modbus dnp3 s7commplus sslproxy $(FILE_INSPECT_DIR)
 
 if FEAT_OPEN_APPID
 SUBDIRS += appid
diff -Nur snort-2.9.17.1/src/dynamic-preprocessors/Makefile.in snort-2.9.17.1_sslproxy/src/dynamic-preprocessors/Makefile.in
--- snort-2.9.17.1/src/dynamic-preprocessors/Makefile.in	2021-03-10 16:08:10.000000000 +0300
+++ snort-2.9.17.1_sslproxy/src/dynamic-preprocessors/Makefile.in	2021-05-30 16:12:32.405394502 +0300
@@ -318,7 +318,7 @@
 ETAGS = etags
 CTAGS = ctags
 DIST_SUBDIRS = . libs ftptelnet pop imap smtp ssh dns ssl dcerpc2 sdf \
-	sip reputation gtp modbus dnp3 s7commplus file appid
+	sip reputation gtp modbus dnp3 s7commplus file appid sslproxy
 am__DIST_COMMON = $(srcdir)/Makefile.in
 DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
 am__relativize = \
@@ -766,7 +766,7 @@
 
 @FEAT_FILE_INSPECT_TRUE@FILE_INSPECT_DIR = file
 SUBDIRS = . libs ftptelnet pop imap smtp ssh dns ssl dcerpc2 sdf sip \
-	reputation gtp modbus dnp3 s7commplus $(FILE_INSPECT_DIR) \
+	reputation gtp modbus dnp3 s7commplus sslproxy $(FILE_INSPECT_DIR) \
 	$(am__append_6)
 EXTRA_DIST = \
 dynamic_preprocessors.vcxproj \
diff -Nur snort-2.9.17.1/src/dynamic-preprocessors/sslproxy/Makefile.am snort-2.9.17.1_sslproxy/src/dynamic-preprocessors/sslproxy/Makefile.am
--- snort-2.9.17.1/src/dynamic-preprocessors/sslproxy/Makefile.am	1970-01-01 02:00:00.000000000 +0200
+++ snort-2.9.17.1_sslproxy/src/dynamic-preprocessors/sslproxy/Makefile.am	2021-05-30 16:12:32.405394502 +0300
@@ -0,0 +1,25 @@
+## $Id
+AUTOMAKE_OPTIONS=foreign no-dependencies
+
+INCLUDES = -I../include -I${srcdir}/../libs -I$(srcdir)/includes
+
+dynamicpreprocessordir = ${libdir}/snort_dynamicpreprocessor
+
+dynamicpreprocessor_LTLIBRARIES = lib_sslproxy_dpp.la
+
+lib_sslproxy_dpp_la_LDFLAGS = -export-dynamic -module @XCCFLAGS@
+if SO_WITH_STATIC_LIB
+lib_sslproxy_dpp_la_LIBADD = ../libsf_dynamic_preproc.la
+else
+nodist_lib_sslproxy_dpp_la_SOURCES = \
+../include/sf_dynamic_preproc_lib.c \
+../include/sfPolicyUserData.c
+endif
+
+lib_sslproxy_dpp_la_SOURCES = spp_sslproxy.c
+
+EXTRA_DIST =
+
+
+all-local: $(LTLIBRARIES)
+	$(MAKE) DESTDIR=`pwd`/../build install-dynamicpreprocessorLTLIBRARIES
diff -Nur snort-2.9.17.1/src/dynamic-preprocessors/sslproxy/Makefile.in snort-2.9.17.1_sslproxy/src/dynamic-preprocessors/sslproxy/Makefile.in
--- snort-2.9.17.1/src/dynamic-preprocessors/sslproxy/Makefile.in	1970-01-01 02:00:00.000000000 +0200
+++ snort-2.9.17.1_sslproxy/src/dynamic-preprocessors/sslproxy/Makefile.in	2021-05-30 16:12:32.405394502 +0300
@@ -0,0 +1,670 @@
+# Makefile.in generated by automake 1.15 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994-2014 Free Software Foundation, Inc.
+
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+VPATH = @srcdir@
+am__is_gnu_make = { \
+  if test -z '$(MAKELEVEL)'; then \
+    false; \
+  elif test -n '$(MAKE_HOST)'; then \
+    true; \
+  elif test -n '$(MAKE_VERSION)' && test -n '$(CURDIR)'; then \
+    true; \
+  else \
+    false; \
+  fi; \
+}
+am__make_running_with_option = \
+  case $${target_option-} in \
+      ?) ;; \
+      *) echo "am__make_running_with_option: internal error: invalid" \
+              "target option '$${target_option-}' specified" >&2; \
+         exit 1;; \
+  esac; \
+  has_opt=no; \
+  sane_makeflags=$$MAKEFLAGS; \
+  if $(am__is_gnu_make); then \
+    sane_makeflags=$$MFLAGS; \
+  else \
+    case $$MAKEFLAGS in \
+      *\\[\ \	]*) \
+        bs=\\; \
+        sane_makeflags=`printf '%s\n' "$$MAKEFLAGS" \
+          | sed "s/$$bs$$bs[$$bs $$bs	]*//g"`;; \
+    esac; \
+  fi; \
+  skip_next=no; \
+  strip_trailopt () \
+  { \
+    flg=`printf '%s\n' "$$flg" | sed "s/$$1.*$$//"`; \
+  }; \
+  for flg in $$sane_makeflags; do \
+    test $$skip_next = yes && { skip_next=no; continue; }; \
+    case $$flg in \
+      *=*|--*) continue;; \
+        -*I) strip_trailopt 'I'; skip_next=yes;; \
+      -*I?*) strip_trailopt 'I';; \
+        -*O) strip_trailopt 'O'; skip_next=yes;; \
+      -*O?*) strip_trailopt 'O';; \
+        -*l) strip_trailopt 'l'; skip_next=yes;; \
+      -*l?*) strip_trailopt 'l';; \
+      -[dEDm]) skip_next=yes;; \
+      -[JT]) skip_next=yes;; \
+    esac; \
+    case $$flg in \
+      *$$target_option*) has_opt=yes; break;; \
+    esac; \
+  done; \
+  test $$has_opt = yes
+am__make_dryrun = (target_option=n; $(am__make_running_with_option))
+am__make_keepgoing = (target_option=k; $(am__make_running_with_option))
+pkgdatadir = $(datadir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkglibexecdir = $(libexecdir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = src/dynamic-preprocessors/sslproxy
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+DIST_COMMON = $(srcdir)/Makefile.am $(am__DIST_COMMON)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_CLEAN_FILES =
+CONFIG_CLEAN_VPATH_FILES =
+am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
+am__vpath_adj = case $$p in \
+    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
+    *) f=$$p;; \
+  esac;
+am__strip_dir = f=`echo $$p | sed -e 's|^.*/||'`;
+am__install_max = 40
+am__nobase_strip_setup = \
+  srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*|]/\\\\&/g'`
+am__nobase_strip = \
+  for p in $$list; do echo "$$p"; done | sed -e "s|$$srcdirstrip/||"
+am__nobase_list = $(am__nobase_strip_setup); \
+  for p in $$list; do echo "$$p $$p"; done | \
+  sed "s| $$srcdirstrip/| |;"' / .*\//!s/ .*/ ./; s,\( .*\)/[^/]*$$,\1,' | \
+  $(AWK) 'BEGIN { files["."] = "" } { files[$$2] = files[$$2] " " $$1; \
+    if (++n[$$2] == $(am__install_max)) \
+      { print $$2, files[$$2]; n[$$2] = 0; files[$$2] = "" } } \
+    END { for (dir in files) print dir, files[dir] }'
+am__base_list = \
+  sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\n/ /g' | \
+  sed '$$!N;$$!N;$$!N;$$!N;s/\n/ /g'
+am__uninstall_files_from_dir = { \
+  test -z "$$files" \
+    || { test ! -d "$$dir" && test ! -f "$$dir" && test ! -r "$$dir"; } \
+    || { echo " ( cd '$$dir' && rm -f" $$files ")"; \
+         $(am__cd) "$$dir" && rm -f $$files; }; \
+  }
+am__installdirs = "$(DESTDIR)$(dynamicpreprocessordir)"
+LTLIBRARIES = $(dynamicpreprocessor_LTLIBRARIES)
+@SO_WITH_STATIC_LIB_TRUE@lib_sslproxy_dpp_la_DEPENDENCIES =  \
+@SO_WITH_STATIC_LIB_TRUE@	../libsf_dynamic_preproc.la
+am_lib_sslproxy_dpp_la_OBJECTS = spp_sslproxy.lo
+@SO_WITH_STATIC_LIB_FALSE@nodist_lib_sslproxy_dpp_la_OBJECTS =  \
+@SO_WITH_STATIC_LIB_FALSE@	sf_dynamic_preproc_lib.lo \
+@SO_WITH_STATIC_LIB_FALSE@	sfPolicyUserData.lo
+lib_sslproxy_dpp_la_OBJECTS = $(am_lib_sslproxy_dpp_la_OBJECTS) \
+	$(nodist_lib_sslproxy_dpp_la_OBJECTS)
+AM_V_lt = $(am__v_lt_@AM_V@)
+am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
+am__v_lt_0 = --silent
+am__v_lt_1 = 
+lib_sslproxy_dpp_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC \
+	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CCLD) \
+	$(AM_CFLAGS) $(CFLAGS) $(lib_sslproxy_dpp_la_LDFLAGS) $(LDFLAGS) \
+	-o $@
+AM_V_P = $(am__v_P_@AM_V@)
+am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
+am__v_P_0 = false
+am__v_P_1 = :
+AM_V_GEN = $(am__v_GEN_@AM_V@)
+am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
+am__v_GEN_0 = @echo "  GEN     " $@;
+am__v_GEN_1 = 
+AM_V_at = $(am__v_at_@AM_V@)
+am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
+am__v_at_0 = @
+am__v_at_1 = 
+DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+depcomp =
+am__depfiles_maybe =
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) \
+	$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \
+	$(AM_CFLAGS) $(CFLAGS)
+AM_V_CC = $(am__v_CC_@AM_V@)
+am__v_CC_ = $(am__v_CC_@AM_DEFAULT_V@)
+am__v_CC_0 = @echo "  CC      " $@;
+am__v_CC_1 = 
+CCLD = $(CC)
+LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
+	$(AM_LDFLAGS) $(LDFLAGS) -o $@
+AM_V_CCLD = $(am__v_CCLD_@AM_V@)
+am__v_CCLD_ = $(am__v_CCLD_@AM_DEFAULT_V@)
+am__v_CCLD_0 = @echo "  CCLD    " $@;
+am__v_CCLD_1 = 
+SOURCES = $(lib_sslproxy_dpp_la_SOURCES) \
+	$(nodist_lib_sslproxy_dpp_la_SOURCES)
+DIST_SOURCES = $(lib_sslproxy_dpp_la_SOURCES)
+am__can_run_installinfo = \
+  case $$AM_UPDATE_INFO_DIR in \
+    n|no|NO) false;; \
+    *) (install-info --version) >/dev/null 2>&1;; \
+  esac
+am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
+# Read a list of newline-separated strings from the standard input,
+# and print each of them once, without duplicates.  Input order is
+# *not* preserved.
+am__uniquify_input = $(AWK) '\
+  BEGIN { nonempty = 0; } \
+  { items[$$0] = 1; nonempty = 1; } \
+  END { if (nonempty) { for (i in items) print i; }; } \
+'
+# Make sure the list of sources is unique.  This is necessary because,
+# e.g., the same source file might be shared among _SOURCES variables
+# for different programs/libraries.
+am__define_uniq_tagged_files = \
+  list='$(am__tagged_files)'; \
+  unique=`for i in $$list; do \
+    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+  done | $(am__uniquify_input)`
+ETAGS = etags
+CTAGS = ctags
+am__DIST_COMMON = $(srcdir)/Makefile.in
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CCONFIGFLAGS = @CCONFIGFLAGS@
+CFLAGS = @CFLAGS@
+CONFIGFLAGS = @CONFIGFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DLLTOOL = @DLLTOOL@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+GREP = @GREP@
+ICONFIGFLAGS = @ICONFIGFLAGS@
+INCLUDES = -I../include -I${srcdir}/../libs -I$(srcdir)/includes
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LEX = @LEX@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+LT_SYS_LIBRARY_PATH = @LT_SYS_LIBRARY_PATH@
+LUA_CFLAGS = @LUA_CFLAGS@
+LUA_LIBS = @LUA_LIBS@
+MAKEINFO = @MAKEINFO@
+MANIFEST_TOOL = @MANIFEST_TOOL@
+MKDIR_P = @MKDIR_P@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+PKG_CONFIG = @PKG_CONFIG@
+PKG_CONFIG_LIBDIR = @PKG_CONFIG_LIBDIR@
+PKG_CONFIG_PATH = @PKG_CONFIG_PATH@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+SIGNAL_SNORT_DUMP_STATS = @SIGNAL_SNORT_DUMP_STATS@
+SIGNAL_SNORT_READ_ATTR_TBL = @SIGNAL_SNORT_READ_ATTR_TBL@
+SIGNAL_SNORT_RELOAD = @SIGNAL_SNORT_RELOAD@
+SIGNAL_SNORT_ROTATE_STATS = @SIGNAL_SNORT_ROTATE_STATS@
+STRIP = @STRIP@
+VERSION = @VERSION@
+XCCFLAGS = @XCCFLAGS@
+YACC = @YACC@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_AR = @ac_ct_AR@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+extra_incl = @extra_incl@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+luajit_CFLAGS = @luajit_CFLAGS@
+luajit_LIBS = @luajit_LIBS@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+runstatedir = @runstatedir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+AUTOMAKE_OPTIONS = foreign no-dependencies
+dynamicpreprocessordir = ${libdir}/snort_dynamicpreprocessor
+dynamicpreprocessor_LTLIBRARIES = lib_sslproxy_dpp.la
+lib_sslproxy_dpp_la_LDFLAGS = -export-dynamic -module @XCCFLAGS@
+@SO_WITH_STATIC_LIB_TRUE@lib_sslproxy_dpp_la_LIBADD = ../libsf_dynamic_preproc.la
+@SO_WITH_STATIC_LIB_FALSE@nodist_lib_sslproxy_dpp_la_SOURCES = \
+@SO_WITH_STATIC_LIB_FALSE@../include/sf_dynamic_preproc_lib.c \
+@SO_WITH_STATIC_LIB_FALSE@../include/sfPolicyUserData.c
+
+lib_sslproxy_dpp_la_SOURCES = \
+spp_sslproxy.c \
+sf_preproc_info.h
+
+EXTRA_DIST = 
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign src/dynamic-preprocessors/sslproxy/Makefile'; \
+	$(am__cd) $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign src/dynamic-preprocessors/sslproxy/Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure:  $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4):  $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(am__aclocal_m4_deps):
+
+install-dynamicpreprocessorLTLIBRARIES: $(dynamicpreprocessor_LTLIBRARIES)
+	@$(NORMAL_INSTALL)
+	@list='$(dynamicpreprocessor_LTLIBRARIES)'; test -n "$(dynamicpreprocessordir)" || list=; \
+	list2=; for p in $$list; do \
+	  if test -f $$p; then \
+	    list2="$$list2 $$p"; \
+	  else :; fi; \
+	done; \
+	test -z "$$list2" || { \
+	  echo " $(MKDIR_P) '$(DESTDIR)$(dynamicpreprocessordir)'"; \
+	  $(MKDIR_P) "$(DESTDIR)$(dynamicpreprocessordir)" || exit 1; \
+	  echo " $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 '$(DESTDIR)$(dynamicpreprocessordir)'"; \
+	  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 "$(DESTDIR)$(dynamicpreprocessordir)"; \
+	}
+
+uninstall-dynamicpreprocessorLTLIBRARIES:
+	@$(NORMAL_UNINSTALL)
+	@list='$(dynamicpreprocessor_LTLIBRARIES)'; test -n "$(dynamicpreprocessordir)" || list=; \
+	for p in $$list; do \
+	  $(am__strip_dir) \
+	  echo " $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f '$(DESTDIR)$(dynamicpreprocessordir)/$$f'"; \
+	  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f "$(DESTDIR)$(dynamicpreprocessordir)/$$f"; \
+	done
+
+clean-dynamicpreprocessorLTLIBRARIES:
+	-test -z "$(dynamicpreprocessor_LTLIBRARIES)" || rm -f $(dynamicpreprocessor_LTLIBRARIES)
+	@list='$(dynamicpreprocessor_LTLIBRARIES)'; \
+	locs=`for p in $$list; do echo $$p; done | \
+	      sed 's|^[^/]*$$|.|; s|/[^/]*$$||; s|$$|/so_locations|' | \
+	      sort -u`; \
+	test -z "$$locs" || { \
+	  echo rm -f $${locs}; \
+	  rm -f $${locs}; \
+	}
+
+lib_sslproxy_dpp.la: $(lib_sslproxy_dpp_la_OBJECTS) $(lib_sslproxy_dpp_la_DEPENDENCIES) $(EXTRA_lib_sslproxy_dpp_la_DEPENDENCIES) 
+	$(AM_V_CCLD)$(lib_sslproxy_dpp_la_LINK) -rpath $(dynamicpreprocessordir) $(lib_sslproxy_dpp_la_OBJECTS) $(lib_sslproxy_dpp_la_LIBADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+.c.o:
+	$(AM_V_CC)$(COMPILE) -c -o $@ $<
+
+.c.obj:
+	$(AM_V_CC)$(COMPILE) -c -o $@ `$(CYGPATH_W) '$<'`
+
+.c.lo:
+	$(AM_V_CC)$(LTCOMPILE) -c -o $@ $<
+
+sf_dynamic_preproc_lib.lo: ../include/sf_dynamic_preproc_lib.c
+	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o sf_dynamic_preproc_lib.lo `test -f '../include/sf_dynamic_preproc_lib.c' || echo '$(srcdir)/'`../include/sf_dynamic_preproc_lib.c
+
+sfPolicyUserData.lo: ../include/sfPolicyUserData.c
+	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o sfPolicyUserData.lo `test -f '../include/sfPolicyUserData.c' || echo '$(srcdir)/'`../include/sfPolicyUserData.c
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+ID: $(am__tagged_files)
+	$(am__define_uniq_tagged_files); mkid -fID $$unique
+tags: tags-am
+TAGS: tags
+
+tags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
+	set x; \
+	here=`pwd`; \
+	$(am__define_uniq_tagged_files); \
+	shift; \
+	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  if test $$# -gt 0; then \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      "$$@" $$unique; \
+	  else \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      $$unique; \
+	  fi; \
+	fi
+ctags: ctags-am
+
+CTAGS: ctags
+ctags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
+	$(am__define_uniq_tagged_files); \
+	test -z "$(CTAGS_ARGS)$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && $(am__cd) $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) "$$here"
+cscopelist: cscopelist-am
+
+cscopelist-am: $(am__tagged_files)
+	list='$(am__tagged_files)'; \
+	case "$(srcdir)" in \
+	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
+	  *) sdir=$(subdir)/$(srcdir) ;; \
+	esac; \
+	for i in $$list; do \
+	  if test -f "$$i"; then \
+	    echo "$(subdir)/$$i"; \
+	  else \
+	    echo "$$sdir/$$i"; \
+	  fi; \
+	done >> $(top_builddir)/cscope.files
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d "$(distdir)/$$file"; then \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
+	  else \
+	    test -f "$(distdir)/$$file" \
+	    || cp -p $$d/$$file "$(distdir)/$$file" \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(LTLIBRARIES) all-local
+installdirs:
+	for dir in "$(DESTDIR)$(dynamicpreprocessordir)"; do \
+	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
+	done
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	if test -z '$(STRIP)'; then \
+	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	      install; \
+	else \
+	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
+	fi
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-dynamicpreprocessorLTLIBRARIES clean-generic \
+	clean-libtool mostlyclean-am
+
+distclean: distclean-am
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+html-am:
+
+info: info-am
+
+info-am:
+
+install-data-am: install-dynamicpreprocessorLTLIBRARIES
+
+install-dvi: install-dvi-am
+
+install-dvi-am:
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-html-am:
+
+install-info: install-info-am
+
+install-info-am:
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-pdf-am:
+
+install-ps: install-ps-am
+
+install-ps-am:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-dynamicpreprocessorLTLIBRARIES
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS TAGS all all-am all-local check check-am clean \
+	clean-dynamicpreprocessorLTLIBRARIES clean-generic \
+	clean-libtool cscopelist-am ctags ctags-am distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-tags distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-dvi \
+	install-dvi-am install-dynamicpreprocessorLTLIBRARIES \
+	install-exec install-exec-am install-html install-html-am \
+	install-info install-info-am install-man install-pdf \
+	install-pdf-am install-ps install-ps-am install-strip \
+	installcheck installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
+	tags tags-am uninstall uninstall-am \
+	uninstall-dynamicpreprocessorLTLIBRARIES
+
+.PRECIOUS: Makefile
+
+
+all-local: $(LTLIBRARIES)
+	$(MAKE) DESTDIR=`pwd`/../build install-dynamicpreprocessorLTLIBRARIES
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -Nur snort-2.9.17.1/src/dynamic-preprocessors/sslproxy/spp_sslproxy.c snort-2.9.17.1_sslproxy/src/dynamic-preprocessors/sslproxy/spp_sslproxy.c
--- snort-2.9.17.1/src/dynamic-preprocessors/sslproxy/spp_sslproxy.c	1970-01-01 02:00:00.000000000 +0200
+++ snort-2.9.17.1_sslproxy/src/dynamic-preprocessors/sslproxy/spp_sslproxy.c	2021-05-30 16:23:59.853178780 +0300
@@ -0,0 +1,753 @@
+/****************************************************************************
+ *
+ * Copyright (C) 2017-2021 Soner Tari <sonertari@gmail.com>. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License Version 2 as
+ * published by the Free Software Foundation.  You may not use, modify or
+ * distribute this program under any other version of the GNU General
+ * Public License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ *
+ ****************************************************************************/
+/*
+ * spp_sslproxy.c
+ *
+ * Author:
+ *
+ * Soner Tari <sonertari@gmail.com>
+ *
+ * Description:
+ *
+ * This file is part of the SSLPROXY project dynamically loadable preprocessor.
+ *
+ * NOTES:
+ * If this preprocessor successfully translates the addresses, the rules make 
+ * use of and the logs report those translated addresses correctly.
+ * 
+ * Note that we cannot translate the addresses in the packets until we receive 
+ * the first packet with the SSLproxy line. Those are usually the three-way
+ * handshake packets.
+ * 
+ * Setting the packet established flag by scb->ha_state.session_flags |= SSNFLAG_ESTABLISHED
+ * fixes the rules with flow: established option. However, a copy of the packet 
+ * with the SSLproxy line still remains as stale, and eventually times out, or 
+ * is processed while snort terminates, whichever happens first.
+ */
+
+#include <assert.h>
+#include <sys/types.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <string.h>
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "sf_types.h"
+#include "preprocids.h"
+#include "sf_snort_packet.h"
+#include "sf_dynamic_preproc_lib.h"
+#include "sf_dynamic_preprocessor.h"
+#include "snort_debug.h"
+#include "sf_preproc_info.h"
+
+#include "sfPolicy.h"
+#include "sfPolicyUserData.h"
+#include "snort_bounds.h"
+
+#include "profiler.h"
+#ifdef PERF_PROFILING
+PreprocStats sslproxyPerfStats;
+#endif
+
+// @todo Use the definition in snort source code or make this a static preprocessor
+// Copied from snort source code
+// this struct is organized by member size for compactness
+typedef struct _SessionControlBlock
+{
+    SessionKey *key;
+
+    void  *proto_specific_data;
+    StreamAppData *appDataList;
+
+    void *flowdata; /* add flowbits */
+
+    long       last_data_seen;
+    uint64_t   expire_time;
+
+    tSfPolicyId napPolicyId;
+    tSfPolicyId ipsPolicyId;
+    void *session_config;
+    void *stream_config;
+    void *proto_policy;
+
+    void *initial_pp;
+    PreprocEnableMask enabled_pps;
+
+    uint16_t    session_state;
+    uint8_t     handler[SE_MAX];
+
+    sfaddr_t    client_ip; // FIXTHIS family and bits should be changed to uint16_t
+    sfaddr_t    server_ip; // or uint8_t to reduce sizeof from 24 to 20
+
+    uint16_t    client_port;
+    uint16_t    server_port;
+    bool        port_guess;
+    bool        stream_config_stale;
+
+    uint8_t     protocol;
+
+#ifdef ACTIVE_RESPONSE
+    uint8_t     response_count;
+#endif
+
+    uint8_t  inner_client_ttl;
+    uint8_t  inner_server_ttl;
+    uint8_t  outer_client_ttl;
+    uint8_t  outer_server_ttl;
+
+    StreamHAState ha_state;
+    StreamHAState cached_ha_state;
+
+#ifdef ENABLE_HA
+    struct timeval  ha_next_update;
+    uint8_t         ha_pending_mask;
+    uint8_t         ha_flags;
+#endif
+
+    bool    ips_os_selected;
+    bool    session_established;
+    bool    new_session;
+    bool    in_oneway_list;
+    bool    is_session_deletion_delayed;
+    uint8_t iprep_update_counter;
+
+    // pointers for linking into list of oneway sessions
+    struct _SessionControlBlock *ows_prev;
+    struct _SessionControlBlock *ows_next;
+
+} SessionControlBlock;
+
+#define GENERATOR_SSLPROXY 10000
+#define PP_SSLPROXY 10000
+#define DST_PORT_MATCH  1
+#define DST_PORT_MATCH_STR "sslproxy_dpp: dst port match, packet processed for SSLproxy"
+#define MAX_PORTS 10
+
+const int MAJOR_VERSION = 2;
+const int MINOR_VERSION = 0;
+const int BUILD_VERSION = 0;
+const char *PREPROC_NAME = "SSLPROXY_PP";
+
+#define SSLproxySetup DYNAMIC_PREPROC_SETUP
+
+typedef struct _SSLproxyConfig
+{
+	int portsToListen[MAX_PORTS + 1];
+
+} SSLproxyConfig;
+
+tSfPolicyUserContextId sslproxy_config = NULL;
+SSLproxyConfig *sslproxy_eval_config = NULL;
+
+static void SSLproxyInit(struct _SnortConfig *, char *);
+static void SSLproxyProcess(void *, void *);
+static SSLproxyConfig * SSLproxyParse(char *);
+#ifdef SNORT_RELOAD
+static void SSLproxyReload(struct _SnortConfig *, char *, void **);
+static int SSLproxyReloadVerify(struct _SnortConfig *, void *);
+static int SSLproxyReloadSwapPolicyFree(tSfPolicyUserContextId, tSfPolicyId, void *);
+static void * SSLproxyReloadSwap(struct _SnortConfig *, void *);
+static void SSLproxyReloadSwapFree(void *);
+#endif
+
+// @todo Use the functions in snort source code or make this a static preprocessor
+// Copied from snort source code
+void sfip_raw_ntop(int family, const void *ip_raw, char *buf, int bufsize)
+{
+    if(!ip_raw || !buf ||
+       (family != AF_INET && family != AF_INET6) ||
+       /* Make sure if it's IPv6 that the buf is large enough. */
+       /* Need atleast a max of 8 fields of 4 bytes plus 7 for colons in
+        * between.  Need 1 more byte for null. */
+       (family == AF_INET6 && bufsize < INET6_ADDRSTRLEN) ||
+       /* Make sure if it's IPv4 that the buf is large enough. */
+       /* 4 fields of 3 numbers, plus 3 dots and a null byte */
+       (family == AF_INET && bufsize < INET_ADDRSTRLEN) )
+    {
+        if(buf && bufsize > 0) buf[0] = 0;
+        return;
+    }
+
+#if defined(HAVE_INET_NTOP) && !defined(REG_TEST)
+    if (!inet_ntop(family, ip_raw, buf, bufsize))
+        snprintf(buf, bufsize, "ERROR");
+#else
+    /* 4 fields of at most 3 characters each */
+    if(family == AF_INET) {
+        int i;
+        uint8_t *p = (uint8_t*)ip_raw;
+
+        for(i=0; p < ((uint8_t*)ip_raw) + 4; p++) {
+            i += sprintf(&buf[i], "%d", *p);
+
+            /* If this is the last iteration, this could technically cause one
+             *  extra byte to be written past the end. */
+            if(i < bufsize && ((p + 1) < ((uint8_t*)ip_raw+4)))
+                buf[i] = '.';
+
+            i++;
+        }
+
+    /* Check if this is really just an IPv4 address represented as 6,
+     * in compatible format */
+#if 0
+    }
+    else if(!field[0] && !field[1] && !field[2]) {
+        unsigned char *p = (unsigned char *)(&ip->ip[12]);
+
+        for(i=0; p < &ip->ip[16]; p++)
+             i += sprintf(&buf[i], "%d.", *p);
+#endif
+    }
+    else {
+        int i;
+        uint16_t *p = (uint16_t*)ip_raw;
+
+        for(i=0; p < ((uint16_t*)ip_raw) + 8; p++) {
+            i += sprintf(&buf[i], "%04x", ntohs(*p));
+
+            /* If this is the last iteration, this could technically cause one
+             *  extra byte to be written past the end. */
+            if(i < bufsize && ((p + 1) < ((uint16_t*)ip_raw) + 8))
+                buf[i] = ':';
+
+            i++;
+        }
+    }
+#endif
+}
+
+void sfip_ntop(const sfaddr_t *ip, char *buf, int bufsize)
+{
+    int family;
+    if(!ip) {
+        if(buf && bufsize > 0) buf[0] = 0;
+        return;
+    }
+
+    family = sfaddr_family(ip);
+    sfip_raw_ntop(family, sfaddr_get_ptr(ip), buf, bufsize);
+}
+
+/* Uses a static buffer to return a string representation of the IP */
+char *sfip_to_str(const sfaddr_t *ip)
+{
+    static char buf[INET6_ADDRSTRLEN];
+
+    sfip_ntop(ip, buf, sizeof(buf));
+
+    return buf;
+}
+
+void SSLproxySetup(void)
+{
+#ifndef SNORT_RELOAD
+	_dpd.registerPreproc("sslproxy", SSLproxyInit);
+#else
+	_dpd.registerPreproc("sslproxy", SSLproxyInit, SSLproxyReload,
+			SSLproxyReloadVerify, SSLproxyReloadSwap, SSLproxyReloadSwapFree);
+#endif
+
+	DEBUG_WRAP(DebugMessage(DEBUG_SSLPROXY, "Preprocessor: SSLproxy is setup\n"););
+}
+
+static void SSLproxyInit(struct _SnortConfig *sc, char *args)
+{
+	SSLproxyConfig *config;
+	tSfPolicyId policy_id = _dpd.getParserPolicy(sc);
+
+	_dpd.logMsg("SSLproxy dynamic preprocessor configuration\n");
+
+	if (sslproxy_config == NULL) {
+		sslproxy_config = sfPolicyConfigCreate();
+		if (sslproxy_config == NULL)
+			_dpd.fatalMsg("Could not allocate configuration struct.\n");
+	}
+
+	config = SSLproxyParse(args);
+	sfPolicyUserPolicySet(sslproxy_config, policy_id);
+	sfPolicyUserDataSetCurrent(sslproxy_config, config);
+
+	/* Register the preprocessor function, Transport layer, ID 10000 */
+	_dpd.addPreproc(sc, SSLproxyProcess, PRIORITY_TRANSPORT, PP_SSLPROXY, PROTO_BIT__TCP);
+
+	if (_dpd.sessionAPI == NULL) {
+		DynamicPreprocessorFatalMessage("Session preprocessor must be enabled for sslproxy preprocessor\n");
+	}
+
+	if (_dpd.streamAPI == NULL) {
+		DynamicPreprocessorFatalMessage("Streaming & reassembly must be enabled for sslproxy preprocessor\n");
+	}
+
+	// Register ports with session and stream
+	_dpd.sessionAPI->enable_preproc_all_ports_all_policies(sc, PP_SSLPROXY, PROTO_BIT__TCP);
+
+	int i;
+	for (i = 0; config->portsToListen[i] != -1 && i < MAX_PORTS; i++) {
+		// SSLproxy info is in packets from client to server only, but we should translate addresses in both directions
+		_dpd.streamAPI->register_reassembly_port(NULL, config->portsToListen[i], SSN_DIR_FROM_SERVER | SSN_DIR_FROM_CLIENT);
+	}
+
+#ifdef PERF_PROFILING
+	_dpd.addPreprocProfileFunc("sslproxy", (void *)&sslproxyPerfStats, 0, _dpd.totalPerfStats, NULL);
+#endif
+
+	DEBUG_WRAP(DebugMessage(DEBUG_SSLPROXY, "Preprocessor: SSLproxy is initialized\n"););
+}
+
+static SSLproxyConfig * SSLproxyParse(char *args)
+{
+	char *argend;
+	int port;
+
+	SSLproxyConfig *config = (SSLproxyConfig *)calloc(1, sizeof(SSLproxyConfig));
+	if (config == NULL)
+		_dpd.fatalMsg("Could not allocate configuration struct.\n");
+
+	#define MAXTOKENS 11
+	char s[512], *p, *tokens[MAXTOKENS];
+	char *last;
+	int i = 0;
+
+	snprintf(s, sizeof(s), "%s", args);
+
+	for ((p = strtok_r(s, " \t\n\r,", &last)); p;
+		(p = strtok_r(NULL, " \t\n\r,", &last))) {
+			if (i < MAXTOKENS - 1)
+					tokens[i++] = p;
+	}
+	tokens[i] = NULL;
+	
+	for (i = 0; i <= MAX_PORTS; i++) {
+		config->portsToListen[i] = -1;
+	}
+
+	if(tokens[0] && !strcasecmp("ports", tokens[0])) {
+		int j = 0;
+		for (i = 1; tokens[i]; i++) {
+			port = strtol(tokens[i], &argend, 10);
+			if (port < 0 || port > 65535) {
+				_dpd.fatalMsg("SSLproxyPreproc: Invalid port %u\n", port);
+			}
+			else {
+				config->portsToListen[j] = port;
+				_dpd.logMsg("	Port: %d\n", config->portsToListen[j]);
+				j++;
+			}
+		}
+	}
+	else {
+		_dpd.fatalMsg("SSLproxyPreproc: Invalid option %s\n", args ? args : "(missing ports)");
+	}
+
+	return config;
+}
+
+void SSLproxyProcess(void *pkt, void *context)
+{
+	SFSnortPacket *p = (SFSnortPacket *)pkt;
+	SSLproxyConfig *config;
+	PROFILE_VARS;
+
+	DEBUG_WRAP(DebugMessage(DEBUG_SSLPROXY, "SSLproxyProcess ENTER\n"););
+
+	sfPolicyUserPolicySet(sslproxy_config, _dpd.getNapRuntimePolicy());
+	config = (SSLproxyConfig *)sfPolicyUserDataGetCurrent(sslproxy_config);
+	if (config == NULL)
+		return;
+
+	// preconditions - what we registered for
+	assert(IsTCP(p));
+
+	PREPROC_PROFILE_START(sslproxyPerfStats);
+
+	int dst_port_match = 0;
+	int src_port_match = 0;
+	int i;
+	for (i = 0; config->portsToListen[i] != -1 && i < MAX_PORTS; i++) {
+		if (p->dst_port == config->portsToListen[i]) {
+			dst_port_match = 1;
+			break;
+		} else if (!src_port_match && p->src_port == config->portsToListen[i]) {
+			src_port_match = 1;
+		}
+	}
+
+	SessionControlBlock *scb = _dpd.sessionAPI->get_session_handle(_dpd.sessionAPI->get_session_key(p));
+
+	if (dst_port_match) {
+		char *sslproxy = NULL;
+		if (p->payload && p->payload_size) {
+			sslproxy = memmem(p->payload, p->payload_size, "SSLproxy:", 9);
+		}
+
+		if (sslproxy) {
+			// SSLproxy: [127.0.0.1]:34649,[192.168.3.24]:47286,[192.168.111.130]:443,s,soner\r\n
+			// 9        + 2 + 45 + 2 + 5  + 2 + 45 + 2 + 5     + 2 + 45 + 2 + 5      + 1 + 1 + 1 + 31 + 2 = 207
+			#define MAX_LINE_LEN 207
+			#define MAX_IPADDR_LEN 45
+			#define MAX_PORT_LEN 5
+			#define MAX_USER_LEN 31
+
+			char line[MAX_LINE_LEN + 1];
+			char sslproxy_src_addr[MAX_IPADDR_LEN + 1];
+			char sslproxy_dst_addr[MAX_IPADDR_LEN + 1];
+			char port[MAX_PORT_LEN + 1];
+
+			int payload_rest_len = p->payload_size - (sslproxy - (char *)p->payload);
+			char *line_end = memmem(sslproxy, payload_rest_len, "\n", 1);
+			if (!line_end) {
+				_dpd.errMsg("SSLproxyPreproc: Cannot find new line: %.*s\n", payload_rest_len, sslproxy);
+				goto out;
+			}
+
+			int line_len = line_end - sslproxy;
+			if (line_len > MAX_LINE_LEN) {
+				_dpd.errMsg("SSLproxyPreproc: line_len greater than MAX_LINE_LEN: %d\n", line_len);
+				goto out;
+			}
+
+			// Trim \n
+			memcpy(line, sslproxy, line_len);
+			// Terminate
+			line[line_len] = '\0';
+
+			// Trim \r
+			if (line[line_len - 1] == '\r') {
+				line[line_len - 1] = '\0';
+			}
+
+			DEBUG_WRAP(DebugMessage(DEBUG_SSLPROXY, "Found: %s\n", line););
+
+			// The checks here cannot cover all possible error conditions
+			// But we should at least avoid crashes, for example caused by passing NULL pointers to str*() functions
+			char *ip_start = strchr(line, '[');
+			if (!ip_start) {
+				DEBUG_WRAP(DebugMessage(DEBUG_SSLPROXY, "Unable to find sslproxy ip_start\n"););
+				_dpd.errMsg("SSLproxyPreproc: Unable to find sslproxy ip_start: %s\n", line);
+				goto out;
+			}
+			ip_start++;
+
+			char *ip_end = strchr(ip_start, ']');
+			if (!ip_end) {
+				DEBUG_WRAP(DebugMessage(DEBUG_SSLPROXY, "Unable to find sslproxy ip_end\n"););
+				_dpd.errMsg("SSLproxyPreproc: Unable to find sslproxy ip_end: %s\n", line);
+				goto out;
+			}
+
+			char *port_start = strchr(ip_end, ':');
+			if (!port_start) {
+				DEBUG_WRAP(DebugMessage(DEBUG_SSLPROXY, "Unable to find sslproxy port_start\n"););
+				_dpd.errMsg("SSLproxyPreproc: Unable to find sslproxy port_start: %s\n", line);
+				goto out;
+			}
+			port_start++;
+
+			char *port_end = strchr(port_start, ',');
+			if (!port_end) {
+				DEBUG_WRAP(DebugMessage(DEBUG_SSLPROXY, "Unable to find sslproxy port_end\n"););
+				_dpd.errMsg("SSLproxyPreproc: Unable to find sslproxy port_end: %s\n", line);
+				goto out;
+			}
+
+			ip_start = strchr(port_end, '[');
+			if (!ip_start) {
+				DEBUG_WRAP(DebugMessage(DEBUG_SSLPROXY, "Unable to find sslproxy src ip_start\n"););
+				_dpd.errMsg("SSLproxyPreproc: Unable to find sslproxy src ip_start: %s\n", line);
+				goto out;
+			}
+			ip_start++;
+
+			ip_end = strchr(ip_start, ']');
+			if (!ip_end) {
+				DEBUG_WRAP(DebugMessage(DEBUG_SSLPROXY, "Unable to find sslproxy src ip_end\n"););
+				_dpd.errMsg("SSLproxyPreproc: Unable to find sslproxy src ip_end: %s\n", line);
+				goto out;
+			}
+
+			port_start = strchr(ip_end, ':');
+			if (!port_start) {
+				DEBUG_WRAP(DebugMessage(DEBUG_SSLPROXY, "Unable to find sslproxy src port_start\n"););
+				_dpd.errMsg("SSLproxyPreproc: Unable to find sslproxy src port_start: %s\n", line);
+				goto out;
+			}
+			port_start++;
+
+			port_end = strchr(port_start, ',');
+			if (!port_end) {
+				DEBUG_WRAP(DebugMessage(DEBUG_SSLPROXY, "Unable to find sslproxy src port_end\n"););
+				_dpd.errMsg("SSLproxyPreproc: Unable to find sslproxy src port_end: %s\n", line);
+				goto out;
+			}
+
+			int addr_len = ip_end - ip_start;
+			if (addr_len > MAX_IPADDR_LEN) {
+				_dpd.errMsg("SSLproxyPreproc: src addr_len greater than MAX_IPADDR_LEN: %d\n", addr_len);
+				goto out;
+			}
+
+			// We can use addr_len for size restriction here, because we check it against MAX_IPADDR_LEN above
+			strncpy(sslproxy_src_addr, ip_start, addr_len);
+			sslproxy_src_addr[addr_len] = '\0';
+
+			int port_len = port_end - port_start;
+			if (port_len > MAX_PORT_LEN) {
+				_dpd.errMsg("SSLproxyPreproc: src port_len greater than MAX_PORT_LEN: %d\n", port_len);
+				goto out;
+			}
+
+			// We can use port_len for size restriction here, because we check it against MAX_PORT_LEN above
+			strncpy(port, port_start, port_len);
+			port[port_len] = '\0';
+			int sslproxy_src_port = atoi(port);
+
+			ip_start = strchr(port_end, '[');
+			if (!ip_start) {
+				DEBUG_WRAP(DebugMessage(DEBUG_SSLPROXY, "Unable to find sslproxy dst ip_start\n"););
+				_dpd.errMsg("SSLproxyPreproc: Unable to find sslproxy dst ip_start: %s\n", line);
+				goto out;
+			}
+			ip_start++;
+
+			ip_end = strchr(ip_start, ']');
+			if (!ip_end) {
+				DEBUG_WRAP(DebugMessage(DEBUG_SSLPROXY, "Unable to find sslproxy dst ip_end\n"););
+				_dpd.errMsg("SSLproxyPreproc: Unable to find sslproxy dst ip_end: %s\n", line);
+				goto out;
+			}
+
+			port_start = strchr(ip_end, ':');
+			if (!port_start) {
+				DEBUG_WRAP(DebugMessage(DEBUG_SSLPROXY, "Unable to find sslproxy dst port_start\n"););
+				_dpd.errMsg("SSLproxyPreproc: Unable to find sslproxy dst port_start: %s\n", line);
+				goto out;
+			}
+			port_start++;
+
+			port_end = strchr(port_start, ',');
+			if (!port_end) {
+				DEBUG_WRAP(DebugMessage(DEBUG_SSLPROXY, "Unable to find sslproxy dst port_end\n"););
+				_dpd.errMsg("SSLproxyPreproc: Unable to find sslproxy dst port_end: %s\n", line);
+				goto out;
+			}
+
+			addr_len = ip_end - ip_start;
+			if (addr_len > MAX_IPADDR_LEN) {
+				_dpd.errMsg("SSLproxyPreproc: dst addr_len greater than MAX_IPADDR_LEN: %d\n", addr_len);
+				goto out;
+			}
+
+			strncpy(sslproxy_dst_addr, ip_start, addr_len);
+			sslproxy_dst_addr[addr_len] = '\0';
+
+			port_len = port_end - port_start;
+			if (port_len > MAX_PORT_LEN) {
+				_dpd.errMsg("SSLproxyPreproc: dst port_len greater than MAX_PORT_LEN: %d\n", port_len);
+				goto out;
+			}
+
+			strncpy(port, port_start, port_len);
+			port[port_len] = '\0';
+			int sslproxy_dst_port = atoi(port);
+
+			char *ssl_start = port_end + 1;
+			char *ssl_end = strchr(ssl_start, ',');
+			char sslproxy_user[MAX_USER_LEN + 1];
+			int ssl_len = 0;
+			if (ssl_end) {
+				// There is user info at the end
+				ssl_len = ssl_end - ssl_start;
+
+				char *user = ssl_end + 1;
+
+				// It is safe to use strlen() here, because we trim the \r\n at the end of line above
+				int user_len = strlen(user);
+				if (user_len > MAX_USER_LEN) {
+					_dpd.errMsg("SSLproxyPreproc: user_len greater than MAX_USER_LEN: %d\n", user_len);
+					goto out;
+				}
+
+				// We can use user_len for size restriction here, because we check it against MAX_USER_LEN above
+				strncpy(sslproxy_user, user, user_len);
+				sslproxy_user[user_len] = '\0';
+			} else {
+				// It is safe to use strlen() here, because we trim the \r\n at the end of line above
+				ssl_len = strlen(ssl_start);
+
+				strncpy(sslproxy_user, "Unknown", 7);
+				sslproxy_user[7] = '\0';
+			}
+
+			if (ssl_len != 1) {
+				_dpd.errMsg("SSLproxyPreproc: ssl_len not 1: %d\n", ssl_len);
+				goto out;
+			}
+
+			if (ssl_start[0] != 'p' && ssl_start[0] != 's') {
+				_dpd.errMsg("SSLproxyPreproc: ssl char not p/s: %c\n", ssl_start[0]);
+				goto out;
+			}
+
+			DEBUG_WRAP(DebugMessage(DEBUG_SSLPROXY, "Parsed SSLproxy line: srcaddr= %s, srcport= %d, dstaddr= %s, dstport= %d, ssl=%d, user= %s\n",
+					sslproxy_src_addr, sslproxy_src_port, sslproxy_dst_addr, sslproxy_dst_port, ssl_start[0] = 's' ? 1 : 0, sslproxy_user););
+
+			DEBUG_WRAP(DebugMessage(DEBUG_SSLPROXY, "ORIG src = %s:%u\n", inet_ntoa(&p->ip4h->ip_addrs->ip_src), p->src_port););
+
+			struct in_addr src_addr;
+			if (inet_pton(AF_INET, sslproxy_src_addr, &src_addr) != 1) {
+				_dpd.errMsg("SSLproxyPreproc: Cannot inet_pton sslproxy_src_addr: %s\n", line);
+				goto out;
+			}
+
+			scb->client_ip.ia32[3] = *((uint32_t *)&src_addr);
+			scb->client_port = htons(sslproxy_src_port);
+			DEBUG_WRAP(DebugMessage(DEBUG_SSLPROXY, "NEW src = %s:%u\n", inet_ntoa(&scb->client_ip), sslproxy_src_port););
+
+			DEBUG_WRAP(DebugMessage(DEBUG_SSLPROXY, "ORIG dst = %s:%u\n", inet_ntoa(&p->ip4h->ip_addrs->ip_dst), p->dst_port););
+
+			struct in_addr dst_addr;
+			if (inet_pton(AF_INET, sslproxy_dst_addr, &dst_addr) != 1) {
+				_dpd.errMsg("SSLproxyPreproc: Cannot inet_pton sslproxy_dst_addr: %s\n", line);
+				goto out;
+			}
+
+			scb->server_ip.ia32[3] = *((uint32_t *)&dst_addr);
+			scb->server_port = htons(sslproxy_dst_port);
+			DEBUG_WRAP(DebugMessage(DEBUG_SSLPROXY, "NEW dst = %s:%u\n", inet_ntoa(&scb->server_ip), sslproxy_dst_port););
+
+			// Set conn established, otherwise rules with flow established option do not work
+			// @attention Note that we cannot set packet established flag directly: p->flags |= PKT_STREAM_EST, MarkupPacketFlags() does that for us
+			scb->ha_state.session_flags |= SSNFLAG_ESTABLISHED;
+
+			// Src and dst addresses updated, log alert
+			_dpd.alertAdd(GENERATOR_SSLPROXY, DST_PORT_MATCH, 1, 0, 3, DST_PORT_MATCH_STR, 0);
+		}
+		else {
+			DEBUG_WRAP(DebugMessage(DEBUG_SSLPROXY, "Cannot find SSLproxy line, translate packet addresses with scb addresses\n"););
+		}
+		p->ip4h->ip_addrs->ip_src.ia32[3]= scb->client_ip.ia32[3];
+		p->src_port = htons(scb->client_port);
+		p->ip4h->ip_addrs->ip_dst.ia32[3]= scb->server_ip.ia32[3];
+		p->dst_port = htons(scb->server_port);
+	}
+	else if (src_port_match) {
+		DEBUG_WRAP(DebugMessage(DEBUG_SSLPROXY, "Reverse direction: src port= %u, dst port= %u\n", p->src_port, p->dst_port););
+
+		p->ip4h->ip_addrs->ip_src.ia32[3]= scb->server_ip.ia32[3];
+		p->src_port = htons(scb->server_port);
+		p->ip4h->ip_addrs->ip_dst.ia32[3]= scb->client_ip.ia32[3];
+		p->dst_port = htons(scb->client_port);
+	}
+	else {
+		// This should never happen since we have already registered for the ports we are interested in
+		_dpd.errMsg("Not a port we are listening for: src port= %u, dst port= %u\n", p->src_port, p->dst_port);
+	}
+out:
+	PREPROC_PROFILE_END(sslproxyPerfStats);
+}
+
+#ifdef SNORT_RELOAD
+static void SSLproxyReload(struct _SnortConfig *sc, char *args, void **new_config)
+{
+	tSfPolicyUserContextId sslproxy_swap_config;
+	SSLproxyConfig *config;
+	tSfPolicyId policy_id = _dpd.getParserPolicy(sc);
+
+	_dpd.logMsg("SSLproxy dynamic preprocessor configuration reloaded\n");
+
+	sslproxy_swap_config = sfPolicyConfigCreate();
+	if (sslproxy_swap_config == NULL)
+		_dpd.fatalMsg("Could not allocate configuration struct.\n");
+
+	config = SSLproxyParse(args);
+	sfPolicyUserPolicySet(sslproxy_swap_config, policy_id);
+	sfPolicyUserDataSetCurrent(sslproxy_swap_config, config);
+
+	/* Register the preprocessor function, Transport layer, ID 10000 */
+	_dpd.addPreproc(sc, SSLproxyProcess, PRIORITY_TRANSPORT, PP_SSLPROXY, PROTO_BIT__TCP);
+
+	if (_dpd.streamAPI == NULL)
+	{
+		DynamicPreprocessorFatalMessage("Streaming & reassembly must be enabled "
+				"for sslproxy preprocessor\n");
+	}
+
+	int i;
+	for (i = 0; config->portsToListen[i] != -1 && i < MAX_PORTS; i++) {
+		// @attention Register ports with session and stream, otherwise we cannot get any packets
+		_dpd.sessionAPI->enable_preproc_for_port(sc, PP_SSLPROXY, PROTO_BIT__TCP, config->portsToListen[i]);
+		// The SSLproxy info is in the packets from client to server only, but do we need stream anyway?
+		_dpd.streamAPI->register_reassembly_port(NULL, config->portsToListen[i], SSN_DIR_FROM_SERVER | SSN_DIR_FROM_CLIENT);
+	}
+
+	*new_config = (void *)sslproxy_swap_config;
+	DEBUG_WRAP(DebugMessage(DEBUG_SSLPROXY, "Preprocessor: SSLproxy is re-initialized\n"););
+}
+
+static int SSLproxyReloadVerify(struct _SnortConfig *sc, void *swap_config)
+{
+	if (!_dpd.isPreprocEnabled(sc, PP_STREAM))
+	{
+		_dpd.errMsg("Streaming & reassembly must be enabled for sslproxy preprocessor\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+static int SSLproxyReloadSwapPolicyFree(tSfPolicyUserContextId config, tSfPolicyId policyId, void *data)
+{
+	SSLproxyConfig *policy_config = (SSLproxyConfig *)data;
+
+	sfPolicyUserDataClear(config, policyId);
+	free(policy_config);
+	return 0;
+}
+
+static void * SSLproxyReloadSwap(struct _SnortConfig *sc, void *swap_config)
+{
+	tSfPolicyUserContextId sslproxy_swap_config = (tSfPolicyUserContextId)swap_config;
+	tSfPolicyUserContextId old_config = sslproxy_config;
+
+	if (sslproxy_swap_config == NULL)
+		return NULL;
+
+	sslproxy_config = sslproxy_swap_config;
+
+	return (void *)old_config;
+}
+
+static void SSLproxyReloadSwapFree(void *data)
+{
+	tSfPolicyUserContextId config = (tSfPolicyUserContextId)data;
+
+	if (data == NULL)
+		return;
+
+	sfPolicyUserDataFreeIterate(config, SSLproxyReloadSwapPolicyFree);
+	sfPolicyConfigDelete(config);
+}
+#endif
+
diff -Nur snort-2.9.17.1/src/preprocessors/spp_session.c snort-2.9.17.1_sslproxy/src/preprocessors/spp_session.c
--- snort-2.9.17.1/src/preprocessors/spp_session.c	2021-03-10 16:05:37.000000000 +0300
+++ snort-2.9.17.1_sslproxy/src/preprocessors/spp_session.c	2021-05-30 16:12:32.405394502 +0300
@@ -1987,7 +1987,7 @@
 
     if(IS_IP4(p))
     {
-        if (sfip_fast_eq4(&p->ip4h->ip_addrs->ip_src, &scb->client_ip))
+        if (sfip_fast_eq4(&p->ip4h->ip_addrs->ip_src, &scb->client_ip) && p->sp == scb->client_port)
         {
             if (GET_IPH_PROTO(p) == IPPROTO_TCP)
                 determinePacketDirection(p, p->tcph->th_sport, scb->client_port, true);
@@ -1996,7 +1996,7 @@
             else
                 p->packet_flags |= PKT_FROM_CLIENT;
         }
-        else if (sfip_fast_eq4(&p->ip4h->ip_addrs->ip_dst, &scb->client_ip))
+        else if (sfip_fast_eq4(&p->ip4h->ip_addrs->ip_dst, &scb->client_ip) && p->dp == scb->client_port)
         {
             if (GET_IPH_PROTO(p) == IPPROTO_TCP)
                 determinePacketDirection(p, p->tcph->th_dport, scb->client_port, false);
@@ -2008,7 +2008,7 @@
     }
     else /* IS_IP6(p) */
     {
-        if (sfip_fast_eq6(&p->ip6h->ip_addrs->ip_src, &scb->client_ip))
+        if (sfip_fast_eq6(&p->ip6h->ip_addrs->ip_src, &scb->client_ip) && p->sp == scb->client_port)
         {
             if (GET_IPH_PROTO(p) == IPPROTO_TCP)
                 determinePacketDirection(p, p->tcph->th_sport, scb->client_port, true);
@@ -2017,7 +2017,7 @@
             else
                 p->packet_flags |= PKT_FROM_CLIENT;
         }
-        else if (sfip_fast_eq6(&p->ip6h->ip_addrs->ip_dst, &scb->client_ip))
+        else if (sfip_fast_eq6(&p->ip6h->ip_addrs->ip_dst, &scb->client_ip) && p->dp == scb->client_port)
         {
             if (GET_IPH_PROTO(p) == IPPROTO_TCP)
                 determinePacketDirection(p, p->tcph->th_dport, scb->client_port, false);
diff -Nur snort-2.9.17.1/src/snort_debug.h snort-2.9.17.1_sslproxy/src/snort_debug.h
--- snort-2.9.17.1/src/snort_debug.h	2021-03-10 16:05:37.000000000 +0300
+++ snort-2.9.17.1_sslproxy/src/snort_debug.h	2021-05-30 16:12:32.409394546 +0300
@@ -77,6 +77,7 @@
 #define DEBUG_SSL             0x0000800000000000LL
 #define DEBUG_SMTP            0x0001000000000000LL
 #define DEBUG_APPID           0x0002000000000000LL
+#define DEBUG_SSLPROXY        0x0004000000000000LL
 #define DEBUG_PP_EXP          0x8000000000000000LL
 
 void DebugMessageFunc(uint64_t dbg, const char *fmt, ...);
